<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DRUMBOSS IPADPRO RELEASE</title>
<style>
  :root{
    --bg:#CCCCCC; --ink:#111; --dim:#888; --line:#000;
    --panel:#F0F0F0; --win:#FFFFFF; --hilite:#A5D4FF; --hilite2:#81B9EF;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);
    font:14px/1.3 "Geneva", "Verdana", sans-serif;}
  .desktop{padding:10px;}
  .window{background:var(--win);border:1px solid #000;
    box-shadow: 2px 2px 0px rgba(0,0,0,0.75); margin:8px 0;}
  .titlebar{
    background-image: repeating-linear-gradient(to bottom, #fff, #fff 1px, #ccc 1px, #ccc 2px);
    border-bottom:1px solid #000;
    padding:6px 10px;display:flex;align-items:center;gap:8px;justify-content:space-between;
  }
  .title{font-weight:normal;}
  .content{padding:10px;}
  .toolbar,.top-controls{
    display:flex;flex-wrap:wrap;gap:10px;align-items:center;
    background:var(--panel);padding:8px;border:1px solid #000;
  }
  label{display:inline-flex;align-items:center;gap:6px;}
  input[type="number"], select, button, input[type="range"]{
    border:1px solid #000;background:#fff;color:#000;padding:2px 4px;
    box-shadow: none; font-size:12px; border-radius: 0;
  }
  button{cursor:pointer; border: 1px solid #000; padding: 1px 6px;}
  .grid-wrap{display:flex;gap:12px;margin-top:10px;}
  .track{min-width:220px;background:var(--panel);border:1px solid #000;}
  .track-head{padding:6px;border-bottom:1px solid #000;background:var(--panel);
    display:flex;flex-direction:column;gap:6px;}
  .track-name{font-weight:bold;}
  .row{display:grid;grid-template-columns:28px 20px 1fr 36px;align-items:center;
    border-bottom:1px dashed #999;padding:2px 4px;gap:6px;}
  .row:last-child{border-bottom:none;}
  .row .idx{font-size:11px;color:var(--dim);text-align:right;}
  .cell{height:18px;display:flex;align-items:center;}
  .vel{width:100%; height:16px;}
  .row.playing{background:var(--hilite);}
  .small{font-size:12px;color:var(--dim);}
  .footer{margin-top:8px;font-size:12px;color:var(--dim);}
  .top-controls{margin:8px 0;}
  .strip{display:flex;gap:8px;flex-wrap:wrap;padding:2px;}
  .card{
    min-width:420px;background:var(--panel);border:1px solid #000;
    padding:6px;
  }
  .card .name{font-weight:bold;margin-bottom:4px;}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:6px;}
  .grid2 label{justify-content:space-between;}
  input[type="range"].wide{width:140px;}
  .card.selectable-param {
    outline: 2px dashed var(--hilite2);
    cursor: pointer;
  }
  .card.selectable-param .grid2 label:hover {
    background: var(--hilite);
  }
</style>
</head>
<body>
<div class="desktop">
  <div class="window">
    <div class="titlebar">
      <div class="title">DrumBoss: IPADPRO release.</div>
      <div class="small">Fm, Synth, Drums, Tribal</div>
    </div>
    <div class="content">
      <!-- Global transport and swing -->
      <div class="toolbar">
        <label>BPM <input id="bpm" type="number" min="40" max="300" value="120"></label>
        <label style="gap:4px;">Swing (8th)
          <input id="swing8" type="range" min="50" max="75" step="0.1" value="50" class="wide">
          <span id="swingVal" class="small">50% (50/50)</span>
        </label>
        <label>Latency
          <select id="latency">
            <option value="interactive" selected>Low</option>
            <option value="balanced">Balanced</option>
            <option value="playback">High</option>
          </select>
        </label>
        <button id="play">Play</button>
        <button id="pause">Pause</button>
        <button id="restart">Restart</button>
        <span class="small">Первая/вторая 16‑я в паре суммарно = 100%.</span>
      </div>

      <!-- Per-track quick controls on top -->
      <div class="top-controls">
        <div id="topStrip" class="strip"></div>
      </div>

      <!-- Pattern grid -->
      <div id="grid" class="grid-wrap"></div>

      <div class="footer">ГУСЯ ЛОВИТЕ В ГОЛОС</div>
    </div>
  </div>
</div>

<script>
(() => {
  // Audio context and scheduler
  let audioCtx = null;
  let isPlaying = false;
  let lookahead = 0.1;      // seconds
  let tickInterval = 25;    // ms
  let timerID = null;

  // Latency setting
  let latencyHint = 'interactive';

  // Swing (8th share: 50–75%)
  let swingPerc = 50;

  const chokeWindow = 0.02; // сек, окно «одновременности» для конфликтов в группе
  const activeByGroup = new Map(); // group -> [voices]

  // 16th duration
  const getStepDur = () => 60 / parseFloat(bpmInput.value) / 4;

  // Utility: white noise buffer
  function createNoiseBuffer(ctx, lengthSec=2){
    const length = Math.floor(ctx.sampleRate * lengthSec);
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<length;i++) data[i] = Math.random()*2-1;
    return buffer;
  }

  // Tracks definition
  const defaultTracks = [
    { name:'Closed Hat', type:'hatC', chokeGroup:1 },
    { name:'Open Hat',   type:'hatO', chokeGroup:1 },
    { name:'Bell',       type:'bell', chokeGroup:0 },
    { name:'Snare',      type:'snare',chokeGroup:0 },
    { name:'Kick 1',     type:'kick', chokeGroup:0, kickTier:'Mid' },
    { name:'Kick 2',     type:'kick', chokeGroup:0, kickTier:'Low' },
  ];

  // App state per track
  const tracks = defaultTracks.map((t,i)=>({
    id:i,
    name:t.name,
    type:t.type,
    enabled:true,
    patternLen:16,
    loopMode:'forward',
    direction:1,
    stepIndex:0,
    nextTime:0,
    swingFirst:true, // первая 16‑я в паре
    // Pattern: velocity per step (0..1). 0 = off
    modulations: {
      velocity: Array(32).fill(0)
    },
    // UI state for modulation
    isModSelectionMode: false,
    currentModulationView: 'velocity',
    isMuted: false,
    // Instrument params + channel params + choke group
    params: instrumentDefaults(t)
  }));

  // Lazy noise buffer
  let noiseBuffer = null;

  const paramInfo = {
    pitchSemis: { min: -24, max: 24, default: 0 },
    cutoff: { min: 200, max: 20000, default: 20000 },
    resonance: { min: 0.1, max: 12, default: 0.7 },
    fmDepthG: { min: 0, max: 800, default: 0 },
    fmRateG: { min: 0, max: 2000, default: 0 },
    fmFeedback: { min: 0, max: 800, default: 0 },
    rmAmt: { min: 0, max: 1, default: 0 },
    rmRate: { min: 0.1, max: 2000, default: 30 },
    gain: { min: 0, max: 1.5, default: 1.0 },
    // Hat
    decay: { min: 0.01, max: 2.0, default: 0.5 },
    bpFreq: { min: 1000, max: 15000, default: 8000 },
    bpQ: { min: 0.1, max: 10, default: 1.0 },
    hpFreq: { min: 1000, max: 15000, default: 5000 },
    tone: { min: 0.1, max: 1.0, default: 0.7 },
    // Bell
    freq: { min: 100, max: 2000, default: 600 },
    ratio: { min: 0.1, max: 5, default: 2 },
    modIndex: { min: 10, max: 2000, default: 600 },
    // Snare
    bodyFreq: { min: 50, max: 500, default: 180 },
    bodyDecay: { min: 0.01, max: 1.0, default: 0.18 },
    noiseLen: { min: 0.01, max: 1.0, default: 0.22 },
    filtEnvAmt: { min: 0, max: 5000, default: 2200 },
    filtEnvTime: { min: 0.01, max: 0.5, default: 0.06 },
    fmDepth: { min: 0, max: 200, default: 40 },
    fmRate: { min: 0, max: 500, default: 120 },
    ringNoiseAmt: { min: 0, max: 1, default: 0.25 },
    // Kick
    startFreq: { min: 20, max: 500, default: 140 },
    endFreq: { min: 20, max: 200, default: 48 },
    click: { min: 0, max: 0.1, default: 0.008 },
  };

  function instrumentDefaults(t){
    const generic = {
      // top controls
      pitchSemis: 0,
      cutoff: 20000, resonance: 0.7,
      fmDepthG: 0, fmRateG: 0, fmFeedback: 0,
      rmAmt: 0, rmRate: 30, rmType: 'sine',
      gain: 1.0,
      chokeGroup: t.chokeGroup ?? 0
    };
    switch(t.type){
      case 'hatC': return Object.assign(generic, { decay:0.06, bpFreq:9000, bpQ:1.0, hpFreq:5000, tone:0.7 });
      case 'hatO': return Object.assign(generic, { decay:0.35, bpFreq:8000, bpQ:0.7, hpFreq:4000, tone:0.6 });
      case 'bell': return Object.assign(generic, { freq:600, ratio:2, modIndex:600, decay:3.5, maxLen:6.0 });
      case 'snare':return Object.assign(generic, { bodyFreq:180, bodyDecay:0.18, noiseLen:0.22,
                            bpFreq:2600, bpQ:1.0, hpFreq:1200,
                            filtEnvAmt:2200, filtEnvTime:0.06,
                            fmDepth:40, fmRate:120,
                            ringNoiseAmt:0.25 });
      case 'kick':
        return Object.assign(generic, { tier:(t.kickTier||'Mid'), startFreq:140, endFreq:48, decay:0.18,
                 fmDepth:60, fmRate:200, click:0.008, gain:0.9 });
      default: return generic;
    }
  }

  // Build UI refs
  const grid = document.getElementById('grid');
  const topStrip = document.getElementById('topStrip');
  const bpmInput = document.getElementById('bpm');
  const swingInput = document.getElementById('swing8');
  const swingVal = document.getElementById('swingVal');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const restartBtn = document.getElementById('restart');
  const latencySelect = document.getElementById('latency');

  latencySelect.addEventListener('change', () => {
    latencyHint = latencySelect.value;
    if (isPlaying) {
      pauseBtn.click();
    }
    if (audioCtx) {
      audioCtx.close().then(() => {
        audioCtx = null;
      });
    }
  });

  function updateSwingLabel(){
    const s = parseFloat(swingInput.value);
    swingPerc = s;
    const first = Math.round(s);
    const second = 100 - first;
    swingVal.textContent = `${first}% (${first}/${second})`;
  }
  swingInput.addEventListener('input', updateSwingLabel);
  updateSwingLabel();

  function handleModParamSelect(paramKey) {
    const modTrack = tracks.find(t => t.isModSelectionMode);
    if (!modTrack) return;

    // Exit selection mode
    modTrack.isModSelectionMode = false;
    const trackUI = grid.querySelector(`.track[data-track="${modTrack.id}"]`);
    const addModBtn = trackUI.querySelector('button'); // A bit fragile, might need a class
    addModBtn.style.outline = '';
    document.querySelectorAll('.card').forEach(c => c.classList.remove('selectable-param'));

    // Add new modulation if it doesn't exist
    if (!modTrack.modulations[paramKey]) {
      const info = paramInfo[paramKey];
      const baseValue = modTrack.params[paramKey] ?? info.default;
      const defaultValue = (baseValue - info.min) / (info.max - info.min);
      modTrack.modulations[paramKey] = Array(32).fill(defaultValue);

      // Update the track's UI
      modTrack.currentModulationView = paramKey;
      const el = grid.querySelector(`.track[data-track="${modTrack.id}"]`);
      if (el) {
        // Re-render the whole track UI to update dropdown and grid
        const newEl = buildTrackUI(modTrack);
        el.parentNode.replaceChild(newEl, el);
      }
    }
  }

  // Build top per-track quick controls (+ choke group)
  function buildTopCard(track){
    const card = document.createElement('div');
    card.className = 'card';
    const name = document.createElement('div'); name.className='name'; name.textContent = track.name;
    card.appendChild(name);
    const grid2 = document.createElement('div'); grid2.className = 'grid2';

    const addNum = (label, key, min, max, step, unit, conv=val=>val) => {
      const wrap = document.createElement('label'); wrap.textContent = label;
      const input = document.createElement('input'); input.type='number';
      input.min=min; input.max=max; input.step=step; input.value=track.params[key];
      input.style.width='70px';
      input.addEventListener('input', ()=> track.params[key]=conv(parseFloat(input.value)));
      wrap.appendChild(input);
      if (unit){ const u = document.createElement('span'); u.textContent = unit; wrap.appendChild(u); }
      grid2.appendChild(wrap);
      wrap.addEventListener('click', () => handleModParamSelect(key));
      return input;
    };
    const addRange = (label, key, min, max, step, wide=false) => {
      const wrap = document.createElement('label'); wrap.textContent=label;
      const rng=document.createElement('input'); rng.type='range';
      rng.min=min; rng.max=max; rng.step=step; rng.value=track.params[key];
      if (wide) rng.classList.add('wide');
      rng.addEventListener('input', ()=> track.params[key]=parseFloat(rng.value));
      wrap.appendChild(rng); grid2.appendChild(wrap);
      wrap.addEventListener('click', () => handleModParamSelect(key));
      return rng;
    };

    addNum('Pitch','pitchSemis',-24,24,1,'st');
    addNum('Cutoff','cutoff',200,20000,10,'Hz');
    addNum('Resonance','resonance',0.1,12,0.1,'Q');
    addNum('FM Depth','fmDepthG',0,800,1,'');
    addNum('FM Rate','fmRateG',0,2000,1,'Hz');
    addNum('FM Feedback','fmFeedback',0,800,1,'');
    addRange('Ring Amt','rmAmt',0,1,0.01,true);
    addNum('Ring Rate','rmRate',0.1,2000,0.1,'Hz');

    const ringTypeWrap = document.createElement('label');
    ringTypeWrap.textContent = 'Ring Type';
    const selRing = document.createElement('select');
    ['sine', 'square', 'sawtooth', 'triangle'].forEach(type => {
        const opt = document.createElement('option');
        opt.value = type;
        opt.textContent = type;
        selRing.appendChild(opt);
    });
    selRing.value = track.params.rmType || 'sine';
    selRing.addEventListener('change', () => track.params.rmType = selRing.value);
    ringTypeWrap.appendChild(selRing);
    grid2.appendChild(ringTypeWrap);

    addRange('Gain', 'gain', 0, 1.5, 0.01, true);

    // Choke group 0..5
    const chokeWrap = document.createElement('label'); chokeWrap.textContent='Choke grp';
    const sel = document.createElement('select');
    [['0','None'],['1','1'],['2','2'],['3','3'],['4','4'],['5','5']].forEach(([v,t])=>{
      const opt=document.createElement('option'); opt.value=v; opt.textContent=t; sel.appendChild(opt);
    });
    sel.value = String(track.params.chokeGroup||0);
    sel.addEventListener('change', ()=> track.params.chokeGroup = parseInt(sel.value,10));
    chokeWrap.appendChild(sel); grid2.appendChild(chokeWrap);

    // Instrument specific controls
    const type = track.type;
    if (type === 'hatC' || type === 'hatO') {
        addNum('Decay', 'decay', 0.01, 2.0, 0.01, 's');
        addNum('BP Freq', 'bpFreq', 1000, 15000, 100, 'Hz');
        addNum('BP Q', 'bpQ', 0.1, 10, 0.1, '');
        addNum('HP Freq', 'hpFreq', 1000, 15000, 100, 'Hz');
        addRange('Tone', 'tone', 0.1, 1.0, 0.01, true);
    } else if (type === 'bell') {
        addNum('Freq', 'freq', 100, 2000, 10, 'Hz');
        addNum('Ratio', 'ratio', 0.1, 5, 0.1, '');
        addNum('Mod Index', 'modIndex', 10, 2000, 10, '');
        addNum('Decay', 'decay', 0.1, 6.0, 0.1, 's');
    } else if (type === 'snare') {
        addNum('Body Freq', 'bodyFreq', 50, 500, 5, 'Hz');
        addNum('Body Decay', 'bodyDecay', 0.01, 1.0, 0.01, 's');
        addNum('Noise Len', 'noiseLen', 0.01, 1.0, 0.01, 's');
        addNum('BP Freq', 'bpFreq', 500, 8000, 100, 'Hz');
        addNum('BP Q', 'bpQ', 0.1, 10, 0.1, '');
        addNum('HP Freq', 'hpFreq', 500, 8000, 100, 'Hz');
        addNum('Filt Env Amt', 'filtEnvAmt', 0, 5000, 100, '');
        addNum('Filt Env Time', 'filtEnvTime', 0.01, 0.5, 0.01, 's');
        addNum('FM Depth', 'fmDepth', 0, 200, 5, '');
        addNum('FM Rate', 'fmRate', 0, 500, 5, 'Hz');
        addRange('Ring Noise', 'ringNoiseAmt', 0, 1, 0.01, true);
    } else if (type === 'kick') {
        const tierWrap = document.createElement('label');
        tierWrap.textContent = 'Tier';
        const tierSel = document.createElement('select');
        ['Low', 'Mid', 'High'].forEach(t => {
            const opt = document.createElement('option');
            opt.value = t;
            opt.textContent = t;
            tierSel.appendChild(opt);
        });
        tierSel.value = track.params.tier || 'Mid';
        tierSel.addEventListener('change', () => track.params.tier = tierSel.value);
        tierWrap.appendChild(tierSel);
        grid2.appendChild(tierWrap);

        addNum('Start Freq', 'startFreq', 20, 500, 10, 'Hz');
        addNum('End Freq', 'endFreq', 20, 200, 5, 'Hz');
        addNum('Decay', 'decay', 0.01, 1.0, 0.01, 's');
        addNum('FM Depth', 'fmDepth', 0, 200, 5, '');
        addNum('FM Rate', 'fmRate', 0, 500, 5, 'Hz');
        addNum('Click', 'click', 0, 0.1, 0.001, 's');
    }

    card.appendChild(grid2);
    return card;
  }

  tracks.forEach(t => topStrip.appendChild(buildTopCard(t)));

  // Build per-track pattern UI (velocity per step)
  function buildTrackUI(track){
    const el = document.createElement('div');
    el.className = 'track'; el.dataset.track = track.id;

    const head = document.createElement('div'); head.className = 'track-head';
    const title = document.createElement('div'); title.className = 'track-name'; title.textContent = track.name;
    head.appendChild(title);

    const ctlRow = document.createElement('div');
    ctlRow.style.display='flex'; ctlRow.style.gap='8px'; ctlRow.style.flexWrap='wrap';

    const lenLabel = document.createElement('label'); lenLabel.textContent = 'Len';
    const lenSel = document.createElement('select');
    for (let i=1;i<=32;i++){
      const opt = document.createElement('option'); opt.value=String(i); opt.textContent=String(i);
      if (i===track.patternLen) opt.selected=true; lenSel.appendChild(opt);
    }
    lenSel.addEventListener('change', () => {
      track.patternLen = parseInt(lenSel.value,10);
      if (track.stepIndex >= track.patternLen) track.stepIndex = 0;
      renderHighlight();
      updateDisabled();
    });
    lenLabel.appendChild(lenSel); ctlRow.appendChild(lenLabel);

    const loopLabel = document.createElement('label'); loopLabel.textContent = 'Loop';
    const loopSel = document.createElement('select');
    ['forward','pingpong'].forEach(m=>{ const opt=document.createElement('option');
      opt.value=m; opt.textContent=(m==='forward'?'Forward':'Ping‑Pong'); loopSel.appendChild(opt); });
    loopSel.value = track.loopMode;
    loopSel.addEventListener('change', ()=> track.loopMode = loopSel.value);
    loopLabel.appendChild(loopSel); ctlRow.appendChild(loopLabel);

    const modLabel = document.createElement('label'); modLabel.textContent = 'View';
    const modSel = document.createElement('select');
    for (const modName in track.modulations) {
      const opt = document.createElement('option');
      opt.value = modName;
      opt.textContent = modName.charAt(0).toUpperCase() + modName.slice(1);
      if (modName === track.currentModulationView) opt.selected = true;
      modSel.appendChild(opt);
    }
    modSel.addEventListener('change', () => {
      track.currentModulationView = modSel.value;
      updateTrackGrid(el, track);
    });
    modLabel.appendChild(modSel); ctlRow.appendChild(modLabel);

    const addModBtn = document.createElement('button');
    addModBtn.textContent = '+M';
    addModBtn.addEventListener('click', () => {
      track.isModSelectionMode = !track.isModSelectionMode;
      addModBtn.style.outline = track.isModSelectionMode ? '2px solid var(--hilite2)' : '';
      document.querySelectorAll('.card').forEach(c => {
        if (track.isModSelectionMode) {
          c.classList.add('selectable-param');
        } else {
          c.classList.remove('selectable-param');
        }
      });
    });
    ctlRow.appendChild(addModBtn);

    const muteBtn = document.createElement('button');
    muteBtn.textContent = 'Mute';
    muteBtn.style.backgroundColor = track.isMuted ? 'var(--hilite2)' : '';
    muteBtn.addEventListener('click', () => {
      track.isMuted = !track.isMuted;
      muteBtn.style.backgroundColor = track.isMuted ? 'var(--hilite2)' : '';
    });
    ctlRow.appendChild(muteBtn);

    head.appendChild(ctlRow);
    el.appendChild(head);

    const gridContent = document.createElement('div');
    el.appendChild(gridContent);

    function updateTrackGrid() {
      gridContent.innerHTML = ''; // Clear previous grid
      const currentMod = track.currentModulationView;
      const modData = track.modulations[currentMod];

      for (let r=0;r<32;r++){
        const row = document.createElement('div'); row.className='row'; row.dataset.row=r;
        const idx = document.createElement('div'); idx.className='idx'; idx.textContent=(r+1).toString().padStart(2,'0');
        const cellOn = document.createElement('div'); cellOn.className='cell';
        const cb = document.createElement('input'); cb.type='checkbox';
        cb.checked = (track.modulations.velocity[r] > 0);
        cellOn.appendChild(cb);

        const velCell = document.createElement('div'); velCell.className='cell';
        const rng = document.createElement('input'); rng.type='range'; rng.min='0'; rng.max='1'; rng.step='0.01';
        rng.value = modData[r] || 0;
        rng.className='vel';
        rng.disabled = !cb.checked;
        velCell.appendChild(rng);

        const velNum = document.createElement('div'); velNum.className='cell small';
        const lbl = document.createElement('span');
        lbl.textContent = Math.round((modData[r]||0)*100).toString();
        velNum.appendChild(lbl);

        cb.addEventListener('change', ()=>{
          rng.disabled = !cb.checked;
          if (cb.checked) {
            if (track.modulations.velocity[r] <= 0) {
              track.modulations.velocity[r] = 0.8;
              if (currentMod === 'velocity') {
                rng.value = 0.8;
                lbl.textContent = '80';
              }
            }
          } else {
            track.modulations.velocity[r] = 0;
            if (currentMod === 'velocity') {
              rng.value = 0;
              lbl.textContent = '0';
            }
          }
        });
        rng.addEventListener('input', ()=>{
          const v = parseFloat(rng.value);
          modData[r] = v;
          lbl.textContent = Math.round(v*100).toString();
        });

        row.appendChild(idx); row.appendChild(cellOn); row.appendChild(velCell); row.appendChild(velNum);
        gridContent.appendChild(row);
      }
      updateDisabled();
    }

    modSel.addEventListener('change', () => {
      track.currentModulationView = modSel.value;
      updateTrackGrid();
    });

    updateTrackGrid();

    function updateDisabled(){
      const rows = el.querySelectorAll('.row');
      rows.forEach((row,idx)=>{
        const cb = row.querySelector('input[type="checkbox"]');
        const rng = row.querySelector('input[type="range"]');
        const dis = (idx>=track.patternLen);
        cb.disabled = dis;
        rng.disabled = dis || !(track.modulations.velocity[idx] > 0);
      });
    }
    updateDisabled();

    return el;
  }

  tracks.forEach(t => grid.appendChild(buildTrackUI(t)));

  // Highlight logic
  function renderHighlight(){
    tracks.forEach(track=>{
      const el = grid.querySelector(`.track[data-track="${track.id}"]`);
      if (!el) return;
      const rows = el.querySelectorAll('.row');
      rows.forEach((row,idx)=>{
        if (idx === track.stepIndex && idx < track.patternLen) row.classList.add('playing');
        else row.classList.remove('playing');
        const cb = row.querySelector('input[type="checkbox"]');
        const rng = row.querySelector('input[type="range"]');
        const dis = (idx>=track.patternLen);
        if (cb) cb.disabled = dis;
        if (rng) rng.disabled = dis || !(track.modulations.velocity[idx] > 0);
      });
    });
  }

  // Transport
  playBtn.addEventListener('click', async ()=>{
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint });
      noiseBuffer = createNoiseBuffer(audioCtx, 2.0);
    }
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    if (isPlaying) return;
    const now = audioCtx.currentTime + 0.05;
    tracks.forEach(t=>{
      t.stepIndex = 0; t.direction = 1; t.nextTime = now; t.swingFirst=true;
    });
    isPlaying = true;
    scheduler();
    timerID = setInterval(scheduler, tickInterval);
    rafLoop();
  });

  pauseBtn.addEventListener('click', async ()=>{
    if (!audioCtx) return;
    await audioCtx.suspend();
    isPlaying = false;
    if (timerID) clearInterval(timerID);
    timerID = null;
  });

  restartBtn.addEventListener('click', ()=>{
    if (!audioCtx) return;
    const now = audioCtx.currentTime + 0.05;
    tracks.forEach(t=>{
      t.stepIndex = 0; t.direction = 1; t.nextTime = now; t.swingFirst=true;
    });
    renderHighlight();
  });

  // Scheduler with look-ahead + 8th swing + choke resolution
  function scheduler(){
    if (!audioCtx) return;
    const baseStep = getStepDur();
    const now = audioCtx.currentTime;
    const horizon = now + lookahead;

    // Collect events first
    const events = []; // {when, track, vel, group}
    tracks.forEach(track=>{
      while (track.nextTime <= horizon){
        const idx = track.stepIndex;
        if (idx < track.patternLen && !track.isMuted){
          const vel = Math.max(0, Math.min(1, track.modulations.velocity[idx]||0));
          if (vel > 0){
            events.push({ when: track.nextTime, track, vel, group: track.params.chokeGroup||0, stepIndex: idx });
          }
        }
        advanceStep(track);
        // 8th swing: pair of 16ths sums to 2*baseStep
        let inc = baseStep;
        if (swingPerc !== 50){
          if (track.swingFirst){
            inc = baseStep * (swingPerc/50); // first of pair
          } else {
            inc = baseStep * ((100 - swingPerc)/50); // second of pair
          }
          track.swingFirst = !track.swingFirst;
        }
        track.nextTime += inc;
      }
    });

    if (events.length === 0) return;

    // Sort by time, then by velocity desc (so при конфликте первым идёт сильнейший)
    events.sort((a,b)=> (a.when===b.when ? (b.vel - a.vel) : (a.when - b.when)));

    // Choke conflict resolution within time window
    const accepted = [];
    const lastByGroup = new Map(); // group -> {when, vel, idxInAccepted}
    events.forEach(e=>{
      const g = e.group|0;
      if (g===0){
        accepted.push(e);
        return;
      }
      const last = lastByGroup.get(g);
      if (!last || Math.abs(e.when - last.when) >= chokeWindow){
        accepted.push(e);
        lastByGroup.set(g, {when:e.when, vel:e.vel, idxInAccepted:accepted.length-1});
      } else {
        // Conflict: keep the higher-velocity one
        if (e.vel > last.vel + 1e-6){
          // Replace previous accepted event
          accepted[last.idxInAccepted] = e;
          lastByGroup.set(g, {when:e.when, vel:e.vel, idxInAccepted:last.idxInAccepted});
        } // else drop current
      }
    });

    // Schedule accepted events with real-time choke of active tails
    accepted.forEach(e=>{
      if (e.group>0) chokeActive(e.group, e.when);
      const voice = trigger(e.track, e.when, e.vel, e.stepIndex);
      if (e.group>0 && voice){
        voice.group = e.group;
        let arr = activeByGroup.get(e.group) || [];
        arr.push(voice);
        activeByGroup.set(e.group, arr);
      }
    });
  }

  function advanceStep(track){
    if (track.loopMode === 'forward'){
      track.stepIndex = (track.stepIndex + 1) % track.patternLen;
      if (swingPerc === 50) track.swingFirst = !track.swingFirst;
    } else {
      let next = track.stepIndex + track.direction;
      if (next >= track.patternLen){ track.direction = -1; next = track.patternLen-2; }
      if (next < 0){ track.direction = 1; next = 1; }
      track.stepIndex = Math.max(0, Math.min(track.patternLen-1, next));
      if (swingPerc === 50) track.swingFirst = !track.swingFirst;
    }
  }

  function rafLoop(){
    if (!isPlaying && (!audioCtx || audioCtx.state!=='running')) return;
    renderHighlight();
    requestAnimationFrame(rafLoop);
  }

  // Stop all active voices in group
  function chokeActive(group, when){
    const arr = activeByGroup.get(group) || [];
    const still = [];
    arr.forEach(v=>{
      if (v.stopAt > when){
        v.stop(when);
        // не возвращаем в still — голос завершён
      }
    });
    activeByGroup.set(group, still);
  }

  // Create a voice gate and stopper
  function createVoiceGate(when, stopAt){
    const gate = audioCtx.createGain();
    gate.gain.setValueAtTime(1, when);
    const voice = {
      gate, stopAt,
      stop: (t)=> {
        const tt = Math.max(t, audioCtx.currentTime);
        try{
          gate.gain.cancelScheduledValues(tt);
          gate.gain.setValueAtTime(gate.gain.value, tt);
          gate.gain.exponentialRampToValueAtTime(0.0001, tt + 0.015);
        }catch(e){}
      }
    };
    return voice;
  }

  // Trigger router: returns voice object (with gate + stopAt) for choke
  function trigger(track, when, velocity=1, stepIndex){
    switch(track.type){
      case 'hatC': return playHat(track, when, false, velocity, stepIndex);
      case 'hatO': return playHat(track, when, true,  velocity, stepIndex);
      case 'bell': return playBell(track, when, velocity, stepIndex);
      case 'snare':return playSnare(track, when, velocity, stepIndex);
      case 'kick': return playKick(track, when, velocity, stepIndex);
    }
  }

  // Channel FX: post lowpass + optional ring mod to out gain
  function channelFX(params, when, stopAt){
    const p = params;
    const lpf = audioCtx.createBiquadFilter();
    lpf.type='lowpass';
    lpf.frequency.setValueAtTime(Math.max(50, p.cutoff||20000), when);
    lpf.Q.setValueAtTime(Math.max(0.1, p.resonance||0.7), when);

    const out = audioCtx.createGain();
    out.gain.setValueAtTime(1, when);

    // Ring modulation on final gain
    const amt = Math.max(0, Math.min(1, p.rmAmt||0));
    if (amt > 0){
      const ring = audioCtx.createOscillator(); ring.type = p.rmType || 'sine';
      ring.frequency.setValueAtTime(Math.max(0.1, p.rmRate||30), when);
      const modGain = audioCtx.createGain(); modGain.gain.setValueAtTime(amt, when);
      const bias = audioCtx.createConstantSource(); bias.offset.setValueAtTime(1 - amt, when);
      ring.connect(modGain).connect(out.gain);
      bias.connect(out.gain);
      ring.start(when); bias.start(when);
      ring.stop(stopAt); bias.stop(stopAt);
    }

    lpf.connect(out).connect(audioCtx.destination);
    return { in:lpf, out };
  }

  function pitchMul(params){
    const semis = params.pitchSemis||0;
    return Math.pow(2, semis/12);
  }

  function effectiveFM(params, fallbackDepth=0, fallbackRate=0){
    const p = params;
    const depth = (p.fmDepthG && p.fmDepthG>0) ? p.fmDepthG : (p.fmDepth || fallbackDepth);
    const rate  = (p.fmRateG  && p.fmRateG>0)  ? p.fmRateG  : (p.fmRate  || fallbackRate);
    const feedback = p.fmFeedback || 0;
    return {depth, rate, feedback};
  }

  function applyModulations(track, stepIndex) {
    const modulatedParams = { ...track.params };
    const step = stepIndex;
    for (const paramName in track.modulations) {
      if (paramName === 'velocity') continue;
      const modValue = track.modulations[paramName][step];
      if (modValue === undefined || modValue === null) continue;

      const info = paramInfo[paramName];
      if (info) {
        const scaledValue = info.min + modValue * (info.max - info.min);
        modulatedParams[paramName] = scaledValue;
      }
    }
    return modulatedParams;
  }

  function playHat(track, when, isOpen, vel, stepIndex){
    const p = applyModulations(track, stepIndex);
    const bus = audioCtx.createGain();

    const src = audioCtx.createBufferSource();
    src.buffer = noiseBuffer;

    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=p.bpFreq; bp.Q.value=p.bpQ;
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=p.hpFreq; hp.Q.value=0.707;

    const amp = audioCtx.createGain();
    const decay = Math.max(0.01, p.decay);
    amp.gain.setValueAtTime(0.0001, when);
    amp.gain.linearRampToValueAtTime(0.9*p.tone*vel*p.gain, when + 0.001);
    amp.gain.exponentialRampToValueAtTime(0.0001, when + decay);

    src.connect(bp).connect(hp).connect(amp).connect(bus);

    const stopAt = when + decay + 0.1;
    const fx = channelFX(p, when, stopAt);
    const voice = createVoiceGate(when, stopAt);
    bus.connect(voice.gate).connect(fx.in);

    src.start(when); src.stop(stopAt);

    return voice;
  }

  function playBell(track, when, vel, stepIndex){
    const p = applyModulations(track, stepIndex);
    const mul = pitchMul(p);
    const dur = Math.min(p.decay, 6.0);
    const bus = audioCtx.createGain();

    const car = audioCtx.createOscillator();
    const mod = audioCtx.createOscillator();
    const modGain = audioCtx.createGain();

    car.type='sine';
    car.frequency.setValueAtTime(p.freq*mul, when);

    const {depth, rate, feedback} = effectiveFM(p, p.modIndex, p.freq * p.ratio);
    mod.type='sine';
    const modFreq = (p.freq*mul) * p.ratio;
    mod.frequency.setValueAtTime(rate>0 ? rate : modFreq, when);
    modGain.gain.setValueAtTime(depth>0 ? depth : p.modIndex, when);
    modGain.gain.exponentialRampToValueAtTime(1.0, when + dur);

    if (feedback>0){
      const fb = audioCtx.createGain(); fb.gain.setValueAtTime(feedback, when);
      mod.connect(fb).connect(mod.frequency);
    }

    const out = audioCtx.createGain();
    out.gain.setValueAtTime(0.0001, when);
    out.gain.linearRampToValueAtTime(0.8*vel*p.gain, when + 0.005);
    out.gain.exponentialRampToValueAtTime(0.0001, when + dur);

    mod.connect(modGain).connect(car.frequency);
    car.connect(out).connect(bus);

    const stopAt = when + dur + 0.05;
    const fx = channelFX(p, when, stopAt);
    const voice = createVoiceGate(when, stopAt);
    bus.connect(voice.gate).connect(fx.in);

    car.start(when); mod.start(when);
    car.stop(stopAt); mod.stop(stopAt);

    return voice;
  }

  function playSnare(track, when, vel, stepIndex){
    const p = applyModulations(track, stepIndex);
    const mul = pitchMul(p);
    const bus = audioCtx.createGain();

    const body = audioCtx.createOscillator();
    body.type='triangle';
    body.frequency.setValueAtTime(p.bodyFreq*mul, when);

    const fm = audioCtx.createOscillator();
    const fmGain = audioCtx.createGain();
    const eff = effectiveFM(p, p.fmDepth, p.fmRate);
    fm.type = 'sine';
    fm.frequency.setValueAtTime(Math.max(1, eff.rate), when);
    fmGain.gain.setValueAtTime(Math.max(0, eff.depth), when);
    fm.connect(fmGain).connect(body.frequency);
    if (eff.feedback>0){
      const fb = audioCtx.createGain(); fb.gain.setValueAtTime(eff.feedback, when);
      fm.connect(fb).connect(fm.frequency);
    }

    const ringNoise = audioCtx.createBufferSource(); ringNoise.buffer = noiseBuffer;
    const ringGain = audioCtx.createGain(); ringGain.gain.setValueAtTime(p.ringNoiseAmt*vel, when);
    const bodyAmp = audioCtx.createGain();
    bodyAmp.gain.setValueAtTime(0.0001, when);
    bodyAmp.gain.linearRampToValueAtTime(0.8*vel*p.gain, when + 0.002);
    bodyAmp.gain.exponentialRampToValueAtTime(0.0001, when + p.bodyDecay);
    const bias = audioCtx.createConstantSource(); bias.offset.setValueAtTime(0.7, when);
    bias.connect(bodyAmp.gain);
    ringNoise.connect(ringGain).connect(bodyAmp.gain);

    const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.setValueAtTime(p.bpFreq, when); bp.Q.value=p.bpQ;
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(p.hpFreq, when); hp.Q.value=0.707;
    const nsGain = audioCtx.createGain();
    nsGain.gain.setValueAtTime(0.0001, when);
    nsGain.gain.linearRampToValueAtTime(0.9*vel*p.gain, when + 0.001);
    nsGain.gain.exponentialRampToValueAtTime(0.0001, when + p.noiseLen);
    bp.frequency.cancelScheduledValues(when);
    bp.frequency.setValueAtTime(p.bpFreq, when);
    bp.frequency.linearRampToValueAtTime(p.bpFreq + p.filtEnvAmt, when + p.filtEnvTime);

    body.connect(bodyAmp).connect(bus);
    ns.connect(bp).connect(hp).connect(nsGain).connect(bus);

    const stopAt = when + Math.max(p.bodyDecay, p.noiseLen) + 0.1;
    const fx = channelFX(p, when, stopAt);
    const voice = createVoiceGate(when, stopAt);
    bus.connect(voice.gate).connect(fx.in);

    body.start(when); fm.start(when); bias.start(when); ringNoise.start(when);
    body.stop(stopAt); fm.stop(stopAt); bias.stop(stopAt); ringNoise.stop(stopAt);
    ns.start(when); ns.stop(stopAt);

    return voice;
  }

  function playKick(track, when, vel, stepIndex){
    const p = applyModulations(track, stepIndex);
    const mul = pitchMul(p);
    const bus = audioCtx.createGain();

    const osc = audioCtx.createOscillator(); osc.type='sine';
    const amp = audioCtx.createGain();
    const out = audioCtx.createGain(); out.gain.value = p.gain * vel;

    const startF = p.startFreq*mul, endF = p.endFreq*mul, decay = p.decay;
    osc.frequency.setValueAtTime(Math.max(20, startF), when);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, endF), when + decay);

    const eff = effectiveFM(p, p.fmDepth, p.fmRate);
    const fm = audioCtx.createOscillator(); fm.type='sine';
    fm.frequency.setValueAtTime(Math.max(1, eff.rate), when);
    const fmGain = audioCtx.createGain();
    fmGain.gain.setValueAtTime(Math.max(0, eff.depth), when);
    fmGain.gain.exponentialRampToValueAtTime(1.0, when + 0.08);
    fm.connect(fmGain).connect(osc.frequency);
    if (eff.feedback>0){
      const fb = audioCtx.createGain(); fb.gain.setValueAtTime(eff.feedback, when);
      fm.connect(fb).connect(fm.frequency);
    }

    amp.gain.setValueAtTime(0.0001, when);
    amp.gain.linearRampToValueAtTime(1.0, when + 0.002);
    amp.gain.exponentialRampToValueAtTime(0.0001, when + Math.max(0.08, decay));

    if (p.click > 0){
      const click = audioCtx.createBufferSource(); click.buffer = noiseBuffer;
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=3000;
      const cGain = audioCtx.createGain();
      cGain.gain.setValueAtTime(0.5*vel, when);
      cGain.gain.exponentialRampToValueAtTime(0.0001, when + p.click);
      click.connect(hp).connect(cGain).connect(bus);
      click.start(when); click.stop(when + p.click + 0.02);
    }

    osc.connect(amp).connect(out).connect(bus);

    const stopAt = when + Math.max(0.25, decay) + 0.05;
    const fx = channelFX(p, when, stopAt);
    const voice = createVoiceGate(when, stopAt);
    bus.connect(voice.gate).connect(fx.in);

    osc.start(when); fm.start(when);
    osc.stop(stopAt); fm.stop(stopAt);

    return voice;
  }

  // Resume on visibility regain (mobile Safari)
  document.addEventListener('visibilitychange', async ()=>{
    if (audioCtx && document.visibilityState==='visible' && audioCtx.state==='suspended'){
      await audioCtx.resume();
    }
  });

})();
</script>
</body>
</html>
